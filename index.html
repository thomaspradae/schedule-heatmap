<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Interactive Schedule Heatmap</title>
  <style>
    /* Base styling */
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 20px;
      background: #121212;
      color: #e0e0e0;
    }
    h1 {
      margin-bottom: 10px;
      font-size: 1.8em;
      text-shadow: 1px 1px 2px #000;
    }
    label, select, button {
      font-size: 1em;
      margin-right: 10px;
    }
    /* Container grid style */
    #scheduleContainer {
      position: relative;
      width: calc(7 * 150px);
      height: calc(38 * 30px); /* 38 half-hour rows from 04:00 to 22:30 */
      margin-top: 20px;
      border: 2px solid #444;
      background: linear-gradient(135deg, #1e1e1e, #2c2c2c);
      box-shadow: 0 4px 8px rgba(0,0,0,0.5);
    }
    .grid-cell {
      position: absolute;
      border: 1px solid rgba(255,255,255,0.1);
      box-sizing: border-box;
    }
    /* Cool event blocks */
    .event-block {
      position: absolute;
      background: linear-gradient(145deg, #007aff, #00d4ff);
      border: 1px solid #005bb5;
      border-radius: 4px;
      color: #fff;
      padding: 2px 4px;
      cursor: move;
      box-sizing: border-box;
      overflow: hidden;
      font-size: 0.75em;
      opacity: 0.92;
      transition: transform 0.1s;
    }
    .event-block:hover {
      box-shadow: 0 4px 6px rgba(0,0,0,0.4);
    }
    #summary {
      margin-top: 20px;
    }
    table {
      border-collapse: collapse;
      margin-top: 10px;
      width: 50%;
    }
    th, td {
      padding: 8px 12px;
      border: 1px solid #555;
      text-align: left;
    }
  </style>
</head>
<body>
  <h1>Interactive Schedule Heatmap</h1>
  <label for="scheduleSelect">Select schedule:</label>
  <select id="scheduleSelect">
      <option value="ana_schedule.csv">Ana's Schedule</option>
      <option value="thomas_schedule.csv">Thomas's Schedule</option>
      <option value="overlay">Overlay Schedules</option>
  </select>
  <button id="loadSchedule">Load Schedule</button>
  
  <div id="summary"></div>
  
  <div id="scheduleContainer"></div>
  
  <!-- Libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js"></script>
  
  <script>
    // Config constants
    const cellWidth = 150;      // per day column width in px
    const cellHeight = 30;      // per half-hour row height
    const baseHour = 4;         // schedule starts at 04:00
    const numRows = 38;         // 38 half-hour intervals (04:00 to 22:30)
    const days = ["Lunes", "Martes", "Miércoles", "Jueves", "Viernes", "Sábado", "Domingo"];

    document.getElementById('loadSchedule').addEventListener('click', () => {
      const file = document.getElementById('scheduleSelect').value;
      if (file === "overlay") {
        // Load both CSVs and merge
        Promise.all([loadCSV("ana_schedule.csv"), loadCSV("thomas_schedule.csv")])
          .then(results => {
            const merged = mergeScheduleMatrices(results[0], results[1]);
            renderSchedule(merged);
            renderSummary(merged);
          })
          .catch(err => console.error("Error loading CSVs for overlay:", err));
      } else {
        loadScheduleCSV(file);
      }
    });

    // Return a Promise that resolves with the parsed CSV data as a matrix (object with day keys)
    function loadCSV(filePath) {
      return new Promise((resolve, reject) => {
        Papa.parse(filePath, {
          download: true,
          complete: function(results) {
            const data = results.data;
            if (Array.isArray(data) && Array.isArray(data[0])) {
              let header = data[0];
              let scheduleMatrix = {};
              for (let i = 1; i < data.length; i++) {
                let row = data[i];
                let time = row[0];
                for (let j = 1; j < header.length; j++) {
                  let day = header[j];
                  if (!scheduleMatrix[day]) scheduleMatrix[day] = [];
                  scheduleMatrix[day].push({ time: time, label: row[j] });
                }
              }
              console.log("Loaded", filePath, scheduleMatrix);
              resolve(scheduleMatrix);
            } else {
              reject("Unexpected CSV format in " + filePath);
            }
          },
          error: function(err) {
            reject(err);
          }
        });
      });
    }

    // For non-overlay, use this function
    function loadScheduleCSV(filePath) {
      loadCSV(filePath)
        .then(matrix => {
          renderSchedule(matrix);
          renderSummary(matrix);
        })
        .catch(err => console.error(err));
    }
    
    // Merge two schedule matrices (assumes same structure and row count per day)
    function mergeScheduleMatrices(m1, m2) {
      let merged = {};
      days.forEach(day => {
        const arr1 = m1[day] || [];
        const arr2 = m2[day] || [];
        let mergedDay = [];
        const maxLen = Math.max(arr1.length, arr2.length);
        for (let i = 0; i < maxLen; i++) {
          const label1 = arr1[i] ? arr1[i].label : "Freespace";
          const label2 = arr2[i] ? arr2[i].label : "Freespace";
          let mergedLabel = "";
          if ((label1 === "Freespace" || !label1.trim()) && (label2 !== "Freespace" && label2.trim())) {
            mergedLabel = label2;
          } else if ((label2 === "Freespace" || !label2.trim()) && (label1 !== "Freespace" && label1.trim())) {
            mergedLabel = label1;
          } else if ((label1 !== "Freespace" && label1.trim()) && (label2 !== "Freespace" && label2.trim())) {
            mergedLabel = label1 + " + " + label2;
          } else {
            mergedLabel = "Freespace";
          }
          mergedDay.push({ time: (arr1[i] ? arr1[i].time : (arr2[i] ? arr2[i].time : indexToTime(i))), label: mergedLabel });
        }
        merged[day] = mergedDay;
      });
      console.log("Merged schedule:", merged);
      return merged;
    }
    
    // Helper: convert HH:MM to row index (0 corresponds to 04:00)
    function timeToIndex(timeStr) {
      let [hours, minutes] = timeStr.split(":").map(Number);
      return ((hours - baseHour) * 60 + minutes) / 30;
    }
    
    // Helper: convert row index back to HH:MM string
    function indexToTime(idx) {
      let totalMins = idx * 30 + baseHour * 60;
      let hrs = Math.floor(totalMins / 60);
      let mins = totalMins % 60;
      return (hrs < 10 ? "0" : "") + hrs + ":" + (mins < 10 ? "0" : "") + mins;
    }
    
    // Group contiguous cells into event blocks per day.
    function groupDayEvents(dayData) {
      let events = []; // each event: { label, startIdx, endIdx }
      dayData.forEach((entry, i) => {
        // Skip if no valid label
        if (!entry || !entry.label || entry.label.trim() === "" || entry.label === "Freespace") return;
        let labels = entry.label.split(" + ");
        labels.forEach(lbl => {
          lbl = lbl.trim();
          if (!lbl) return;
          let last = events.length ? events[events.length - 1] : null;
          if (last && last.label === lbl && last.endIdx === i) {
            last.endIdx = i + 1;
          } else {
            events.push({ label: lbl, startIdx: i, endIdx: i + 1 });
          }
        });
      });
      return events;
    }
    
    // Assign overlapping events levels so they can be offset horizontally.
    function assignLevels(events) {
      events.sort((a,b) => a.startIdx - b.startIdx);
      events.forEach(ev => {
        let level = 0;
        while(events.some(other => other !== ev &&
              other.level === level &&
              other.startIdx < ev.endIdx &&
              other.endIdx > ev.startIdx)) {
          level++;
        }
        ev.level = level;
      });
      let maxLevel = events.reduce((max, ev) => Math.max(max, ev.level), 0);
      return { events, maxLevel };
    }
    
    // Render the interactive schedule grid with event blocks overlaid.
    function renderSchedule(scheduleMatrix) {
      console.log("Rendering schedule:", scheduleMatrix);
      const container = document.getElementById("scheduleContainer");
      container.innerHTML = "";  // clear previous
      
      // Draw grid background lines
      for(let i = 0; i <= numRows; i++) {
         let line = document.createElement("div");
         line.style.position = "absolute";
         line.style.top = (i * cellHeight) + "px";
         line.style.left = "0px";
         line.style.width = (cellWidth * days.length) + "px";
         line.style.height = "1px";
         line.style.background = "rgba(255,255,255,0.1)";
         container.appendChild(line);
      }
      for(let j = 0; j <= days.length; j++){
         let line = document.createElement("div");
         line.style.position = "absolute";
         line.style.left = (j * cellWidth) + "px";
         line.style.top = "0px";
         line.style.height = (numRows * cellHeight) + "px";
         line.style.width = "1px";
         line.style.background = "rgba(255,255,255,0.1)";
         container.appendChild(line);
      }
      
      // Render events per day
      days.forEach((day, dayIndex) => {
        if(!scheduleMatrix[day]) return;
        let dayEvents = groupDayEvents(scheduleMatrix[day]);
        if(dayEvents.length === 0) return;
        
        let { events, maxLevel } = assignLevels(dayEvents);
        events.forEach(ev => {
          let duration = ev.endIdx - ev.startIdx;
          let topPos = ev.startIdx * cellHeight;
          let availableWidth = cellWidth - 6;
          let eventWidth = availableWidth / (maxLevel + 1);
          let leftPos = dayIndex * cellWidth + ev.level * eventWidth + 2;
          let block = document.createElement("div");
          block.className = "event-block";
          block.textContent = `${ev.label} (${indexToTime(ev.startIdx)} - ${indexToTime(ev.endIdx)})`;
          block.style.top = topPos + "px";
          block.style.left = leftPos + "px";
          block.style.width = (eventWidth - 4) + "px";
          block.style.height = (duration * cellHeight - 4) + "px";
          block.dataset.day = dayIndex;
          block.dataset.startIdx = ev.startIdx;
          block.dataset.duration = duration;
          block.dataset.label = ev.label;
          container.appendChild(block);
        });
      });
      enableDragging();
    }
    
    // Enable drag-and-drop using Interact.js.
    function enableDragging() {
      interact('.event-block').draggable({
        inertia: true,
        modifiers: [
          interact.modifiers.restrictRect({
            restriction: document.getElementById('scheduleContainer'),
            endOnly: true
          })
        ],
        autoScroll: true,
        onmove: dragMoveListener,
        onend: function(event) {
          let target = event.target;
          let x = parseFloat(target.getAttribute('data-x')) || 0;
          let y = parseFloat(target.getAttribute('data-y')) || 0;
          x = Math.round(x / cellWidth) * cellWidth;
          y = Math.round(y / cellHeight) * cellHeight;
          target.style.transform = `translate(${x}px, ${y}px)`;
          target.setAttribute('data-x', x);
          target.setAttribute('data-y', y);
          let newDay = Math.floor(x / cellWidth);
          let newStartIdx = y / cellHeight;
          target.dataset.day = newDay;
          target.dataset.startIdx = newStartIdx;
          let newTime = indexToTime(newStartIdx);
          let newEnd = indexToTime(newStartIdx + parseInt(target.dataset.duration));
          target.textContent = target.dataset.label + " (" + newTime + " - " + newEnd + ")";
          updateSummary();
        }
      });
      
      function dragMoveListener(event) {
        let target = event.target;
        let x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx;
        let y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;
        target.style.transform = `translate(${x}px, ${y}px)`;
        target.setAttribute('data-x', x);
        target.setAttribute('data-y', y);
      }
    }
    
    // Build an activity summary (total hours per activity) using the raw matrix.
    function renderSummary(scheduleMatrix) {
      let counts = {};
      days.forEach(day => {
        if(scheduleMatrix[day]) {
          scheduleMatrix[day].forEach(entry => {
            if(entry.label && entry.label !== "Freespace") {
              entry.label.split(" + ").forEach(lbl => {
                lbl = lbl.trim();
                if (!lbl) return;
                counts[lbl] = (counts[lbl] || 0) + 0.5;
              });
            }
          });
        }
      });
      let summaryDiv = document.getElementById("summary");
      summaryDiv.innerHTML = "<h2>Activity Summary (Hours)</h2>";
      let table = document.createElement("table");
      let headerRow = document.createElement("tr");
      ["Activity", "Hours"].forEach(text => {
        let th = document.createElement("th");
        th.textContent = text;
        headerRow.appendChild(th);
      });
      table.appendChild(headerRow);
      for (let act in counts) {
        let tr = document.createElement("tr");
        let td1 = document.createElement("td");
        td1.textContent = act;
        let td2 = document.createElement("td");
        td2.textContent = counts[act];
        tr.appendChild(td1);
        tr.appendChild(td2);
        table.appendChild(tr);
      }
      summaryDiv.appendChild(table);
    }
    
    // Dummy updateSummary – reloads the currently selected CSV (or overlay) to recalc summary.
    function updateSummary() {
      const file = document.getElementById('scheduleSelect').value;
      if(file === "overlay") {
        Promise.all([loadCSV("ana_schedule.csv"), loadCSV("thomas_schedule.csv")])
          .then(results => {
            const merged = mergeScheduleMatrices(results[0], results[1]);
            renderSummary(merged);
          });
      } else {
        loadCSV(file).then(matrix => renderSummary(matrix));
      }
    }
  </script>
</body>
</html>
